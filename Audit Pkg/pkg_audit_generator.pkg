CREATE OR REPLACE PACKAGE BODY pkg_audit_generator AS
    c_null_token CONSTANT VARCHAR2(20) := '#~NULL~#';

    FUNCTION normalize_name(p_name IN VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        RETURN UPPER(DBMS_ASSERT.SIMPLE_SQL_NAME(TRIM(p_name)));
    END normalize_name;

    FUNCTION default_trigger_name(p_table_name IN VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        RETURN 'TRG_AUD_' || SUBSTR(p_table_name, 1, 22);
    END default_trigger_name;

    FUNCTION normalize_yes_no(
        p_value     IN CHAR,
        p_paramname IN VARCHAR2
    ) RETURN CHAR IS
        v_value CHAR(1) := UPPER(TRIM(p_value));
    BEGIN
        IF v_value NOT IN ('Y', 'N') THEN
            RAISE_APPLICATION_ERROR(-20003, p_paramname || ' must be Y or N.');
        END IF;

        RETURN v_value;
    END normalize_yes_no;

    FUNCTION normalize_name_csv(p_csv IN VARCHAR2) RETURN VARCHAR2 IS
        v_out   VARCHAR2(32767);
        v_token VARCHAR2(4000);
        v_idx   PLS_INTEGER := 1;
    BEGIN
        LOOP
            v_token := REGEXP_SUBSTR(p_csv, '[^,]+', 1, v_idx);
            EXIT WHEN v_token IS NULL;

            v_token := normalize_name(v_token);

            IF v_out IS NULL THEN
                v_out := v_token;
            ELSE
                v_out := v_out || ',' || v_token;
            END IF;

            v_idx := v_idx + 1;
        END LOOP;

        RETURN v_out;
    END normalize_name_csv;

    FUNCTION normalize_text_csv(p_csv IN VARCHAR2) RETURN VARCHAR2 IS
        v_out   VARCHAR2(32767);
        v_token VARCHAR2(4000);
        v_idx   PLS_INTEGER := 1;
    BEGIN
        LOOP
            v_token := REGEXP_SUBSTR(p_csv, '[^,]+', 1, v_idx);
            EXIT WHEN v_token IS NULL;

            v_token := UPPER(TRIM(v_token));

            IF v_token IS NOT NULL THEN
                IF v_out IS NULL THEN
                    v_out := v_token;
                ELSE
                    v_out := v_out || ',' || v_token;
                END IF;
            END IF;

            v_idx := v_idx + 1;
        END LOOP;

        RETURN v_out;
    END normalize_text_csv;

    FUNCTION contains_csv(
        p_csv   IN VARCHAR2,
        p_token IN VARCHAR2
    ) RETURN BOOLEAN IS
    BEGIN
        IF p_csv IS NULL OR p_token IS NULL THEN
            RETURN FALSE;
        END IF;

        RETURN INSTR(',' || p_csv || ',', ',' || p_token || ',') > 0;
    END contains_csv;

    FUNCTION is_lob_type(p_data_type IN VARCHAR2) RETURN BOOLEAN IS
    BEGIN
        RETURN p_data_type IN ('CLOB', 'NCLOB');
    END is_lob_type;

    FUNCTION is_supported_type(p_data_type IN VARCHAR2) RETURN BOOLEAN IS
    BEGIN
        RETURN p_data_type IN (
            'CHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR2',
            'NUMBER', 'FLOAT', 'BINARY_FLOAT', 'BINARY_DOUBLE',
            'DATE', 'TIMESTAMP', 'TIMESTAMP WITH TIME ZONE',
            'TIMESTAMP WITH LOCAL TIME ZONE',
            'INTERVAL YEAR TO MONTH', 'INTERVAL DAY TO SECOND',
            'CLOB', 'NCLOB'
        );
    END is_supported_type;

    FUNCTION value_expr(
        p_alias      IN VARCHAR2,
        p_column     IN VARCHAR2,
        p_data_type  IN VARCHAR2
    ) RETURN VARCHAR2 IS
        v_col VARCHAR2(4000);
    BEGIN
        v_col := p_alias || '."' || p_column || '"';

        IF p_data_type IN ('CHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR2') THEN
            RETURN v_col;
        ELSIF p_data_type IN ('NUMBER', 'FLOAT', 'BINARY_FLOAT', 'BINARY_DOUBLE') THEN
            RETURN 'TO_CHAR(' || v_col || ')';
        ELSIF p_data_type = 'DATE' THEN
            RETURN 'TO_CHAR(' || v_col || ', ''YYYY-MM-DD HH24:MI:SS'')';
        ELSIF p_data_type = 'TIMESTAMP' THEN
            RETURN 'TO_CHAR(' || v_col || ', ''YYYY-MM-DD HH24:MI:SS.FF6'')';
        ELSIF p_data_type IN ('TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE') THEN
            RETURN 'TO_CHAR(' || v_col || ', ''YYYY-MM-DD HH24:MI:SS.FF6 TZH:TZM'')';
        ELSIF p_data_type IN ('INTERVAL YEAR TO MONTH', 'INTERVAL DAY TO SECOND') THEN
            RETURN 'TO_CHAR(' || v_col || ')';
        ELSIF p_data_type IN ('CLOB', 'NCLOB') THEN
            RETURN 'DBMS_LOB.SUBSTR(' || v_col || ', 4000, 1)';
        END IF;

        RETURN 'NULL';
    END value_expr;

    PROCEDURE append_line(
        p_ddl  IN OUT NOCOPY CLOB,
        p_line IN VARCHAR2
    ) IS
    BEGIN
        p_ddl := p_ddl || p_line || CHR(10);
    END append_line;

    FUNCTION pk_expr(p_table_name IN VARCHAR2, p_alias IN VARCHAR2) RETURN VARCHAR2 IS
        v_expr  VARCHAR2(32767);
        v_count PLS_INTEGER := 0;
    BEGIN
        FOR pk_col IN (
            SELECT cc.column_name, tc.data_type
            FROM user_constraints c
            JOIN user_cons_columns cc
                ON cc.constraint_name = c.constraint_name
               AND cc.table_name = c.table_name
            JOIN user_tab_columns tc
                ON tc.table_name = cc.table_name
               AND tc.column_name = cc.column_name
            WHERE c.table_name = p_table_name
              AND c.constraint_type = 'P'
            ORDER BY cc.position
        ) LOOP
            v_count := v_count + 1;

            IF v_count > 1 THEN
                v_expr := v_expr || ' || ''|'' || ';
            END IF;

            v_expr := v_expr
                || 'NVL('
                || value_expr(p_alias, pk_col.column_name, pk_col.data_type)
                || ', '''
                || c_null_token
                || ''')';
        END LOOP;

        IF v_count = 0 THEN
            RAISE_APPLICATION_ERROR(
                -20001,
                'Cannot generate audit trigger: table '
                || p_table_name
                || ' has no primary key.'
            );
        END IF;

        RETURN v_expr;
    END pk_expr;

    FUNCTION build_trigger_ddl(
        p_table_name         IN VARCHAR2,
        p_trigger_name       IN VARCHAR2,
        p_include_insert_row IN CHAR,
        p_include_delete_row IN CHAR,
        p_include_columns    IN VARCHAR2,
        p_exclude_columns    IN VARCHAR2,
        p_skip_datatypes     IN VARCHAR2,
        p_include_lobs       IN CHAR,
        p_bulk_mode          IN CHAR,
        p_json_mode          IN CHAR
    ) RETURN CLOB IS
        v_ddl         CLOB;
        v_pk_old_expr VARCHAR2(32767);
        v_pk_new_expr VARCHAR2(32767);
        v_has_columns BOOLEAN := FALSE;
        v_take_column BOOLEAN;
    BEGIN
        v_pk_old_expr := pk_expr(p_table_name, ':OLD');
        v_pk_new_expr := pk_expr(p_table_name, ':NEW');

        append_line(v_ddl, 'CREATE OR REPLACE TRIGGER ' || p_trigger_name);
        append_line(v_ddl, 'FOR INSERT OR UPDATE OR DELETE ON "' || p_table_name || '"');
        append_line(v_ddl, 'COMPOUND TRIGGER');
        append_line(v_ddl, '    v_enabled       audit_config.audit_enabled%TYPE := ''N'';');
        append_line(v_ddl, '    v_audit_insert  audit_config.audit_insert%TYPE := ''N'';');
        append_line(v_ddl, '    v_audit_update  audit_config.audit_update%TYPE := ''N'';');
        append_line(v_ddl, '    v_audit_delete  audit_config.audit_delete%TYPE := ''N'';');
        append_line(v_ddl, '    v_pk_value      VARCHAR2(100);');

        IF p_json_mode = 'Y' THEN
            append_line(v_ddl, '    v_json_old      CLOB;');
            append_line(v_ddl, '    v_json_new      CLOB;');
            append_line(v_ddl, '    v_json_old_sep  VARCHAR2(1);');
            append_line(v_ddl, '    v_json_new_sep  VARCHAR2(1);');
            append_line(v_ddl, '    v_json_changed  BOOLEAN := FALSE;');
            append_line(v_ddl, '');
            append_line(v_ddl, '    FUNCTION json_quote(p_value IN VARCHAR2) RETURN VARCHAR2 IS');
            append_line(v_ddl, '    BEGIN');
            append_line(v_ddl, '        IF p_value IS NULL THEN');
            append_line(v_ddl, '            RETURN ''null'';');
            append_line(v_ddl, '        END IF;');
            append_line(v_ddl, '        RETURN CHR(34)');
            append_line(v_ddl, '            || REPLACE(');
            append_line(v_ddl, '                REPLACE(');
            append_line(v_ddl, '                    REPLACE(');
            append_line(v_ddl, '                        REPLACE(p_value, CHR(92), CHR(92) || CHR(92)),');
            append_line(v_ddl, '                        CHR(34), CHR(92) || CHR(34)');
            append_line(v_ddl, '                    ),');
            append_line(v_ddl, '                    CHR(10), ''\n''');
            append_line(v_ddl, '                ),');
            append_line(v_ddl, '                CHR(13), ''\r''');
            append_line(v_ddl, '            )');
            append_line(v_ddl, '            || CHR(34);');
            append_line(v_ddl, '    END json_quote;');
            append_line(v_ddl, '');
            append_line(v_ddl, '    PROCEDURE add_json_pair(');
            append_line(v_ddl, '        p_json IN OUT NOCOPY CLOB,');
            append_line(v_ddl, '        p_sep  IN OUT VARCHAR2,');
            append_line(v_ddl, '        p_key  IN VARCHAR2,');
            append_line(v_ddl, '        p_val  IN VARCHAR2');
            append_line(v_ddl, '    ) IS');
            append_line(v_ddl, '    BEGIN');
            append_line(v_ddl, '        p_json := p_json || p_sep || ''"'' || p_key || ''":'' || json_quote(p_val);');
            append_line(v_ddl, '        p_sep := '','';');
            append_line(v_ddl, '    END add_json_pair;');
        END IF;

        IF p_bulk_mode = 'Y' THEN
            append_line(v_ddl, '');
            append_line(v_ddl, '    g_changes       audit_pkg.t_change_tab;');
            append_line(v_ddl, '    g_idx           PLS_INTEGER := 0;');
            append_line(v_ddl, '');
            append_line(v_ddl, '    PROCEDURE add_change(');
            append_line(v_ddl, '        p_table_name  IN VARCHAR2,');
            append_line(v_ddl, '        p_column_name IN VARCHAR2,');
            append_line(v_ddl, '        p_pk_value    IN VARCHAR2,');
            append_line(v_ddl, '        p_old_value   IN VARCHAR2,');
            append_line(v_ddl, '        p_new_value   IN VARCHAR2,');
            append_line(v_ddl, '        p_action      IN VARCHAR2,');
            append_line(v_ddl, '        p_change_json IN CLOB DEFAULT NULL');
            append_line(v_ddl, '    ) IS');
            append_line(v_ddl, '    BEGIN');
            append_line(v_ddl, '        g_idx := g_idx + 1;');
            append_line(v_ddl, '        g_changes(g_idx).table_name := p_table_name;');
            append_line(v_ddl, '        g_changes(g_idx).column_name := p_column_name;');
            append_line(v_ddl, '        g_changes(g_idx).pk_value := p_pk_value;');
            append_line(v_ddl, '        g_changes(g_idx).old_value := p_old_value;');
            append_line(v_ddl, '        g_changes(g_idx).new_value := p_new_value;');
            append_line(v_ddl, '        g_changes(g_idx).json_payload := p_change_json;');
            append_line(v_ddl, '        g_changes(g_idx).action_type := p_action;');
            append_line(v_ddl, '    END add_change;');
        END IF;

        append_line(v_ddl, '');
        append_line(v_ddl, '    BEFORE STATEMENT IS');
        append_line(v_ddl, '    BEGIN');
        append_line(v_ddl, '        BEGIN');
        append_line(v_ddl, '            SELECT audit_enabled, audit_insert, audit_update, audit_delete');
        append_line(v_ddl, '            INTO v_enabled, v_audit_insert, v_audit_update, v_audit_delete');
        append_line(v_ddl, '            FROM audit_config');
        append_line(v_ddl, '            WHERE table_name = ''' || p_table_name || ''';');
        append_line(v_ddl, '        EXCEPTION');
        append_line(v_ddl, '            WHEN NO_DATA_FOUND THEN');
        append_line(v_ddl, '                NULL;');
        append_line(v_ddl, '        END;');
        append_line(v_ddl, '    END BEFORE STATEMENT;');

        append_line(v_ddl, '');
        append_line(v_ddl, '    AFTER EACH ROW IS');
        append_line(v_ddl, '    BEGIN');
        append_line(v_ddl, '        IF v_enabled <> ''Y'' THEN');
        append_line(v_ddl, '            RETURN;');
        append_line(v_ddl, '        END IF;');
        append_line(v_ddl, '');
        append_line(v_ddl, '        IF INSERTING AND v_audit_insert = ''Y'' THEN');
        append_line(v_ddl, '            v_pk_value := ' || v_pk_new_expr || ';');

        IF p_include_insert_row = 'Y' THEN
            IF p_bulk_mode = 'Y' THEN
                append_line(v_ddl, '            add_change(''' || p_table_name || ''', NULL, v_pk_value, NULL, NULL, ''INSERT'');');
            ELSE
                append_line(v_ddl, '            audit_pkg.log_change(''' || p_table_name || ''', NULL, v_pk_value, NULL, NULL, ''INSERT'');');
            END IF;
        END IF;

        append_line(v_ddl, '        ELSIF DELETING AND v_audit_delete = ''Y'' THEN');
        append_line(v_ddl, '            v_pk_value := ' || v_pk_old_expr || ';');

        IF p_include_delete_row = 'Y' THEN
            IF p_bulk_mode = 'Y' THEN
                append_line(v_ddl, '            add_change(''' || p_table_name || ''', NULL, v_pk_value, NULL, NULL, ''DELETE'');');
            ELSE
                append_line(v_ddl, '            audit_pkg.log_change(''' || p_table_name || ''', NULL, v_pk_value, NULL, NULL, ''DELETE'');');
            END IF;
        END IF;

        append_line(v_ddl, '        ELSIF UPDATING AND v_audit_update = ''Y'' THEN');
        append_line(v_ddl, '            v_pk_value := ' || v_pk_old_expr || ';');

        IF p_json_mode = 'Y' THEN
            append_line(v_ddl, '            v_json_old := ''{'';');
            append_line(v_ddl, '            v_json_new := ''{'';');
            append_line(v_ddl, '            v_json_old_sep := NULL;');
            append_line(v_ddl, '            v_json_new_sep := NULL;');
            append_line(v_ddl, '            v_json_changed := FALSE;');
        END IF;

        FOR col_rec IN (
            SELECT column_name, data_type
            FROM user_tab_columns
            WHERE table_name = p_table_name
            ORDER BY column_id
        ) LOOP
            v_take_column := is_supported_type(col_rec.data_type);

            IF v_take_column AND p_include_lobs = 'N' AND is_lob_type(col_rec.data_type) THEN
                v_take_column := FALSE;
            END IF;

            IF v_take_column AND p_include_columns IS NOT NULL AND NOT contains_csv(p_include_columns, col_rec.column_name) THEN
                v_take_column := FALSE;
            END IF;

            IF v_take_column AND p_exclude_columns IS NOT NULL AND contains_csv(p_exclude_columns, col_rec.column_name) THEN
                v_take_column := FALSE;
            END IF;

            IF v_take_column AND p_skip_datatypes IS NOT NULL AND contains_csv(p_skip_datatypes, col_rec.data_type) THEN
                v_take_column := FALSE;
            END IF;

            IF v_take_column THEN
                v_has_columns := TRUE;
                append_line(v_ddl,
                    '            IF NVL(' || value_expr(':OLD', col_rec.column_name, col_rec.data_type) || ', '''
                    || c_null_token || ''') <> NVL(' || value_expr(':NEW', col_rec.column_name, col_rec.data_type)
                    || ', ''' || c_null_token || ''') THEN');

                IF p_bulk_mode = 'Y' THEN
                    append_line(v_ddl,
                        '                add_change(''' || p_table_name || ''', '''
                        || col_rec.column_name || ''', v_pk_value, '
                        || value_expr(':OLD', col_rec.column_name, col_rec.data_type) || ', '
                        || value_expr(':NEW', col_rec.column_name, col_rec.data_type) || ', ''UPDATE'');');
                ELSE
                    append_line(v_ddl,
                        '                audit_pkg.log_change(''' || p_table_name || ''', '''
                        || col_rec.column_name || ''', v_pk_value, '
                        || value_expr(':OLD', col_rec.column_name, col_rec.data_type) || ', '
                        || value_expr(':NEW', col_rec.column_name, col_rec.data_type) || ', ''UPDATE'');');
                END IF;

                IF p_json_mode = 'Y' THEN
                    append_line(v_ddl,
                        '                add_json_pair(v_json_old, v_json_old_sep, ''' || col_rec.column_name || ''', '
                        || value_expr(':OLD', col_rec.column_name, col_rec.data_type) || ');');
                    append_line(v_ddl,
                        '                add_json_pair(v_json_new, v_json_new_sep, ''' || col_rec.column_name || ''', '
                        || value_expr(':NEW', col_rec.column_name, col_rec.data_type) || ');');
                    append_line(v_ddl, '                v_json_changed := TRUE;');
                END IF;

                append_line(v_ddl, '            END IF;');
            END IF;
        END LOOP;

        IF NOT v_has_columns THEN
            RAISE_APPLICATION_ERROR(
                -20002,
                'Cannot generate audit trigger: table '
                || p_table_name
                || ' has no included/supported columns for UPDATE auditing.'
            );
        END IF;

        IF p_json_mode = 'Y' THEN
            append_line(v_ddl, '            IF v_json_changed THEN');
            append_line(v_ddl, '                v_json_old := v_json_old || ''}'';');
            append_line(v_ddl, '                v_json_new := v_json_new || ''}'';');
            IF p_bulk_mode = 'Y' THEN
                append_line(v_ddl,
                    '                add_change(''' || p_table_name || ''', ''ROW_JSON'', v_pk_value, NULL, NULL, ''UPDATE'', '
                    || '''{"old":'' || v_json_old || '',''"new":'' || v_json_new || ''}'');');
            ELSE
                append_line(v_ddl,
                    '                audit_pkg.log_change(''' || p_table_name || ''', ''ROW_JSON'', v_pk_value, NULL, NULL, ''UPDATE'', '
                    || '''{"old":'' || v_json_old || '',''"new":'' || v_json_new || ''}'');');
            END IF;
            append_line(v_ddl, '            END IF;');
        END IF;

        append_line(v_ddl, '        END IF;');
        append_line(v_ddl, '    END AFTER EACH ROW;');

        IF p_bulk_mode = 'Y' THEN
            append_line(v_ddl, '');
            append_line(v_ddl, '    AFTER STATEMENT IS');
            append_line(v_ddl, '    BEGIN');
            append_line(v_ddl, '        IF v_enabled = ''Y'' AND g_changes.COUNT > 0 THEN');
            append_line(v_ddl, '            audit_pkg.flush_changes(g_changes);');
            append_line(v_ddl, '        END IF;');
            append_line(v_ddl, '    END AFTER STATEMENT;');
        END IF;

        append_line(v_ddl, 'END ' || p_trigger_name || ';');

        RETURN v_ddl;
    END build_trigger_ddl;

    PROCEDURE upsert_config(
        p_table_name         IN VARCHAR2,
        p_trigger_name       IN VARCHAR2,
        p_include_insert_row IN CHAR,
        p_include_delete_row IN CHAR,
        p_include_columns    IN VARCHAR2,
        p_exclude_columns    IN VARCHAR2,
        p_skip_datatypes     IN VARCHAR2,
        p_include_lobs       IN CHAR,
        p_bulk_mode          IN CHAR,
        p_json_mode          IN CHAR
    ) IS
    BEGIN
        MERGE INTO audit_generator_config c
        USING (
            SELECT
                p_table_name AS table_name,
                p_trigger_name AS trigger_name,
                p_include_insert_row AS include_insert_row,
                p_include_delete_row AS include_delete_row,
                p_include_columns AS include_columns,
                p_exclude_columns AS exclude_columns,
                p_skip_datatypes AS skip_datatypes,
                p_include_lobs AS include_lobs,
                p_bulk_mode AS bulk_mode,
                p_json_mode AS json_mode
            FROM dual
        ) d
        ON (c.table_name = d.table_name)
        WHEN MATCHED THEN
            UPDATE SET
                c.trigger_name = d.trigger_name,
                c.include_insert_row = d.include_insert_row,
                c.include_delete_row = d.include_delete_row,
                c.include_columns = d.include_columns,
                c.exclude_columns = d.exclude_columns,
                c.skip_datatypes = d.skip_datatypes,
                c.include_lobs = d.include_lobs,
                c.bulk_mode = d.bulk_mode,
                c.json_mode = d.json_mode,
                c.updated_at = SYSDATE
        WHEN NOT MATCHED THEN
            INSERT (
                table_name, trigger_name, include_insert_row, include_delete_row,
                include_columns, exclude_columns, skip_datatypes,
                include_lobs, bulk_mode, json_mode, updated_at
            )
            VALUES (
                d.table_name, d.trigger_name, d.include_insert_row, d.include_delete_row,
                d.include_columns, d.exclude_columns, d.skip_datatypes,
                d.include_lobs, d.bulk_mode, d.json_mode, SYSDATE
            );
    END upsert_config;

    PROCEDURE upsert_generated_trigger(
        p_table_name         IN VARCHAR2,
        p_trigger_name       IN VARCHAR2,
        p_include_insert_row IN CHAR,
        p_include_delete_row IN CHAR,
        p_include_columns    IN VARCHAR2,
        p_exclude_columns    IN VARCHAR2,
        p_skip_datatypes     IN VARCHAR2,
        p_include_lobs       IN CHAR,
        p_bulk_mode          IN CHAR,
        p_json_mode          IN CHAR
    ) IS
        v_user VARCHAR2(30) := NVL(SYS_CONTEXT('USERENV', 'SESSION_USER'), 'UNKNOWN');
    BEGIN
        MERGE INTO audit_generated_trigger g
        USING (
            SELECT
                p_table_name AS table_name,
                p_trigger_name AS trigger_name,
                p_include_insert_row AS include_insert_row,
                p_include_delete_row AS include_delete_row,
                p_include_columns AS include_columns,
                p_exclude_columns AS exclude_columns,
                p_skip_datatypes AS skip_datatypes,
                p_include_lobs AS include_lobs,
                p_bulk_mode AS bulk_mode,
                p_json_mode AS json_mode,
                v_user AS generated_by
            FROM dual
        ) d
        ON (g.table_name = d.table_name)
        WHEN MATCHED THEN
            UPDATE SET
                g.trigger_name = d.trigger_name,
                g.include_insert_row = d.include_insert_row,
                g.include_delete_row = d.include_delete_row,
                g.include_columns = d.include_columns,
                g.exclude_columns = d.exclude_columns,
                g.skip_datatypes = d.skip_datatypes,
                g.include_lobs = d.include_lobs,
                g.bulk_mode = d.bulk_mode,
                g.json_mode = d.json_mode,
                g.generated_by = d.generated_by,
                g.generated_at = SYSDATE
        WHEN NOT MATCHED THEN
            INSERT (
                table_name, trigger_name, include_insert_row, include_delete_row,
                include_columns, exclude_columns, skip_datatypes,
                include_lobs, bulk_mode, json_mode, generated_by, generated_at
            )
            VALUES (
                d.table_name, d.trigger_name, d.include_insert_row, d.include_delete_row,
                d.include_columns, d.exclude_columns, d.skip_datatypes,
                d.include_lobs, d.bulk_mode, d.json_mode, d.generated_by, SYSDATE
            );
    END upsert_generated_trigger;

    PROCEDURE delete_generated_trigger(p_table_name IN VARCHAR2) IS
    BEGIN
        DELETE FROM audit_generated_trigger
        WHERE table_name = p_table_name;
    END delete_generated_trigger;

    PROCEDURE execute_ddl(p_ddl IN CLOB) IS
        v_cursor INTEGER := NULL;
    BEGIN
        v_cursor := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_cursor, p_ddl, DBMS_SQL.NATIVE);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
    EXCEPTION
        WHEN OTHERS THEN
            IF v_cursor IS NOT NULL THEN
                IF DBMS_SQL.IS_OPEN(v_cursor) THEN
                    DBMS_SQL.CLOSE_CURSOR(v_cursor);
                END IF;
            END IF;
            RAISE;
    END execute_ddl;

    PROCEDURE save_config(
        p_table_name         IN VARCHAR2,
        p_trigger_name       IN VARCHAR2 DEFAULT NULL,
        p_include_insert_row IN CHAR DEFAULT 'Y',
        p_include_delete_row IN CHAR DEFAULT 'Y',
        p_include_columns    IN VARCHAR2 DEFAULT NULL,
        p_exclude_columns    IN VARCHAR2 DEFAULT NULL,
        p_skip_datatypes     IN VARCHAR2 DEFAULT NULL,
        p_include_lobs       IN CHAR DEFAULT 'N',
        p_bulk_mode          IN CHAR DEFAULT 'Y',
        p_json_mode          IN CHAR DEFAULT 'N'
    ) IS
        v_table_name         VARCHAR2(30);
        v_trigger_name       VARCHAR2(30);
        v_include_insert_row CHAR(1);
        v_include_delete_row CHAR(1);
        v_include_lobs       CHAR(1);
        v_bulk_mode          CHAR(1);
        v_json_mode          CHAR(1);
        v_include_columns    VARCHAR2(32767);
        v_exclude_columns    VARCHAR2(32767);
        v_skip_datatypes     VARCHAR2(32767);
    BEGIN
        v_table_name := normalize_name(p_table_name);
        v_trigger_name := normalize_name(NVL(p_trigger_name, default_trigger_name(v_table_name)));

        IF LENGTH(v_trigger_name) > 30 THEN
            RAISE_APPLICATION_ERROR(-20006, 'Trigger name exceeds 30 characters: ' || v_trigger_name);
        END IF;

        v_include_insert_row := normalize_yes_no(p_include_insert_row, 'p_include_insert_row');
        v_include_delete_row := normalize_yes_no(p_include_delete_row, 'p_include_delete_row');
        v_include_lobs := normalize_yes_no(p_include_lobs, 'p_include_lobs');
        v_bulk_mode := normalize_yes_no(p_bulk_mode, 'p_bulk_mode');
        v_json_mode := normalize_yes_no(p_json_mode, 'p_json_mode');

        v_include_columns := normalize_name_csv(p_include_columns);
        v_exclude_columns := normalize_name_csv(p_exclude_columns);
        v_skip_datatypes := normalize_text_csv(p_skip_datatypes);

        upsert_config(
            p_table_name         => v_table_name,
            p_trigger_name       => v_trigger_name,
            p_include_insert_row => v_include_insert_row,
            p_include_delete_row => v_include_delete_row,
            p_include_columns    => v_include_columns,
            p_exclude_columns    => v_exclude_columns,
            p_skip_datatypes     => v_skip_datatypes,
            p_include_lobs       => v_include_lobs,
            p_bulk_mode          => v_bulk_mode,
            p_json_mode          => v_json_mode
        );
    END save_config;

    PROCEDURE clear_config(
        p_table_name IN VARCHAR2
    ) IS
        v_table_name VARCHAR2(30);
    BEGIN
        v_table_name := normalize_name(p_table_name);

        DELETE FROM audit_generator_config
        WHERE table_name = v_table_name;
    END clear_config;

    PROCEDURE generate_trigger(
        p_table_name         IN VARCHAR2,
        p_trigger_name       IN VARCHAR2 DEFAULT NULL,
        p_include_insert_row IN CHAR DEFAULT 'Y',
        p_include_delete_row IN CHAR DEFAULT 'Y',
        p_include_columns    IN VARCHAR2 DEFAULT NULL,
        p_exclude_columns    IN VARCHAR2 DEFAULT NULL,
        p_skip_datatypes     IN VARCHAR2 DEFAULT NULL,
        p_include_lobs       IN CHAR DEFAULT 'N',
        p_bulk_mode          IN CHAR DEFAULT 'Y',
        p_json_mode          IN CHAR DEFAULT 'N'
    ) IS
        v_table_name         VARCHAR2(30);
        v_trigger_name       VARCHAR2(30);
        v_ddl                CLOB;
        v_exists             PLS_INTEGER;
        v_include_insert_row CHAR(1);
        v_include_delete_row CHAR(1);
        v_include_lobs       CHAR(1);
        v_bulk_mode          CHAR(1);
        v_json_mode          CHAR(1);
        v_include_columns    VARCHAR2(32767);
        v_exclude_columns    VARCHAR2(32767);
        v_skip_datatypes     VARCHAR2(32767);
    BEGIN
        v_table_name := normalize_name(p_table_name);
        v_trigger_name := normalize_name(NVL(p_trigger_name, default_trigger_name(v_table_name)));

        IF LENGTH(v_trigger_name) > 30 THEN
            RAISE_APPLICATION_ERROR(-20006, 'Trigger name exceeds 30 characters: ' || v_trigger_name);
        END IF;

        v_include_insert_row := normalize_yes_no(p_include_insert_row, 'p_include_insert_row');
        v_include_delete_row := normalize_yes_no(p_include_delete_row, 'p_include_delete_row');
        v_include_lobs := normalize_yes_no(p_include_lobs, 'p_include_lobs');
        v_bulk_mode := normalize_yes_no(p_bulk_mode, 'p_bulk_mode');
        v_json_mode := normalize_yes_no(p_json_mode, 'p_json_mode');

        v_include_columns := normalize_name_csv(p_include_columns);
        v_exclude_columns := normalize_name_csv(p_exclude_columns);
        v_skip_datatypes := normalize_text_csv(p_skip_datatypes);

        SELECT COUNT(*)
        INTO v_exists
        FROM user_tables
        WHERE table_name = v_table_name;

        IF v_exists = 0 THEN
            RAISE_APPLICATION_ERROR(-20005, 'Table not found in current schema: ' || v_table_name);
        END IF;

        v_ddl := build_trigger_ddl(
            p_table_name         => v_table_name,
            p_trigger_name       => v_trigger_name,
            p_include_insert_row => v_include_insert_row,
            p_include_delete_row => v_include_delete_row,
            p_include_columns    => v_include_columns,
            p_exclude_columns    => v_exclude_columns,
            p_skip_datatypes     => v_skip_datatypes,
            p_include_lobs       => v_include_lobs,
            p_bulk_mode          => v_bulk_mode,
            p_json_mode          => v_json_mode
        );

        execute_ddl(v_ddl);

        upsert_generated_trigger(
            p_table_name         => v_table_name,
            p_trigger_name       => v_trigger_name,
            p_include_insert_row => v_include_insert_row,
            p_include_delete_row => v_include_delete_row,
            p_include_columns    => v_include_columns,
            p_exclude_columns    => v_exclude_columns,
            p_skip_datatypes     => v_skip_datatypes,
            p_include_lobs       => v_include_lobs,
            p_bulk_mode          => v_bulk_mode,
            p_json_mode          => v_json_mode
        );
    END generate_trigger;

    PROCEDURE generate_trigger_from_config(
        p_table_name IN VARCHAR2
    ) IS
        v_table_name         VARCHAR2(30);
        v_trigger_name       VARCHAR2(30);
        v_include_insert_row CHAR(1);
        v_include_delete_row CHAR(1);
        v_include_columns    VARCHAR2(4000);
        v_exclude_columns    VARCHAR2(4000);
        v_skip_datatypes     VARCHAR2(4000);
        v_include_lobs       CHAR(1);
        v_bulk_mode          CHAR(1);
        v_json_mode          CHAR(1);
    BEGIN
        v_table_name := normalize_name(p_table_name);

        SELECT
            NVL(trigger_name, default_trigger_name(v_table_name)),
            NVL(include_insert_row, 'Y'),
            NVL(include_delete_row, 'Y'),
            include_columns,
            exclude_columns,
            skip_datatypes,
            NVL(include_lobs, 'N'),
            NVL(bulk_mode, 'Y'),
            NVL(json_mode, 'N')
        INTO
            v_trigger_name,
            v_include_insert_row,
            v_include_delete_row,
            v_include_columns,
            v_exclude_columns,
            v_skip_datatypes,
            v_include_lobs,
            v_bulk_mode,
            v_json_mode
        FROM audit_generator_config
        WHERE table_name = v_table_name;

        generate_trigger(
            p_table_name         => v_table_name,
            p_trigger_name       => v_trigger_name,
            p_include_insert_row => v_include_insert_row,
            p_include_delete_row => v_include_delete_row,
            p_include_columns    => v_include_columns,
            p_exclude_columns    => v_exclude_columns,
            p_skip_datatypes     => v_skip_datatypes,
            p_include_lobs       => v_include_lobs,
            p_bulk_mode          => v_bulk_mode,
            p_json_mode          => v_json_mode
        );
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(
                -20007,
                'No generator config found for table: ' || v_table_name
            );
    END generate_trigger_from_config;

    PROCEDURE drop_trigger(
        p_table_name   IN VARCHAR2,
        p_trigger_name IN VARCHAR2 DEFAULT NULL
    ) IS
        v_table_name   VARCHAR2(30);
        v_trigger_name VARCHAR2(30);
    BEGIN
        v_table_name := normalize_name(p_table_name);
        v_trigger_name := normalize_name(NVL(p_trigger_name, default_trigger_name(v_table_name)));

        BEGIN
            EXECUTE IMMEDIATE 'DROP TRIGGER ' || v_trigger_name;
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -4080 THEN
                    RAISE;
                END IF;
        END;

        delete_generated_trigger(v_table_name);
    END drop_trigger;
END pkg_audit_generator;
/
